$public
enum s32 {
    MMAP_PROT_NONE = 0,
    MMAP_PROT_READ = 1,
    MMAP_PROT_WRITE = 2,
    MMAP_PROT_EXEC = 4,
    MMAP_PROT_GROSDOWN = 16777216,
    MMAP_PROT_GROWSUP = 33554432,
}

$public
enum s32 {
    MMAP_FLAGS_FILE = 0,
    MMAP_FLAGS_SHARED = 1,
    MMAP_FLAGS_PRIVATE = 2,
    MMAP_FLAGS_SHARED_VALIDATE = 3,
    MMAP_FLAGS_FIXED = 10,
    MMAP_FLAGS_TYPE = 16,
    MMAP_FLAGS_ANONYMOUS = 20,
    MMAP_FLAGS_GROWSDOWN = 256,
    MMAP_FLAGS_DENY_WRITE = 2048,
    MMAP_FLAGS_EXECUTABLE = 4096,
    MMAP_FLAGS_LOCKED = 8192,
    MMAP_FLAGS_NO_RESERVE = 16384,
    MMAP_FLAGS_POPULATE = 32768,
    MMAP_FLAGS_NON_BLOCK = 65536,
}

BlockMeta :: struct {
    size: u64,
    next: *BlockMeta,
    free: bool,
    mmap: bool,
}

_G_brkp :: mut *void = null;
_G_bhead :: mut *BlockMeta = null;

$public
brk :: (addr: *void) -> s64 {
    let new: *void;
    __asm__ (
        "movq $$12, %rax\n"
        "movq $1, %rdi\n"
        "syscall\n"
        "movq %rax, $0"
        : "=r" (new)
        : "r" (addr)
        : "rax", "rdi"
    );

    if !new
        ret -1;

    ret 0;
}

$public
sbrk :: (inc: u64) -> *void {
    if !_G_brkp {
        __asm__ (
            "movq $$12, %rax\n"
            "movq $$0, %rdi\n"
            "syscall\n"
            "movq %rax, $0"
            : "=m" (_G_brkp)
            :
            : "rax", "rdi"  
        );

        if !_G_brkp
            ret -1;
    }

    if inc == 0
        ret _G_brkp;

    let old: *void = _G_brkp;
    let new: *void = cast<*char>(_G_brkp) + inc;

    if brk(new) == -1
        ret -1;

    ret _G_brkp = new;
}

$public
mmap :: (addr: *void, len: u64, prot: s32, flags: s32, fd: s64, 
         offset: u64) -> *void {
    let ptr: *void;
    __asm__ (
        "movq $$9, %rax\n"
        "movq $1, %rdi\n"
        "movq $2, %rsi\n"
        "movl $3, %edx\n"
        "movl $4, %ecx\n"
        "movq $5, %r8\n"
        "movq $6, %r9\n"
        "syscall\n"
        "movq %rax, $0"
        : "=r" (ptr)
        : "r" (addr), "r" (len), "r" (prot), "r" (flags), "r" (fd), "r" (offset)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r8", "r9"
    );
    ret ptr;
}

$public
munmap :: (addr: *void, len: u64) -> s64 {
    let result: mut s64;
    __asm__ (
        "movq $$11, %rax\n"
        "movq $1, %rdi\n"
        "movq $2, %rsi\n"
        "syscall\n"
        "movq %rax, $0"
        : "=r" (result)
        : "r" (addr), "r" (len)
        : "rax", "rdi", "rsi"
    );
    ret result;
}

find_free_space :: (last: mut **BlockMeta, size: u64) -> *BlockMeta {
    $assert(last && "last cannot be null!");

    let curr: mut *BlockMeta = _G_bhead;
    while curr {
        if curr.free && curr.size >= size
            break;

        *last = curr;
        curr = curr.next;
    }

    ret curr;
}

request_space :: (last: mut *BlockMeta, size: u64) -> *BlockMeta {
    let total_size: u64 = size + sizeof(BlockMeta);
    $assert(total_size >= size && "integer overflow detected!");

    let block: mut *BlockMeta = null;
    let mem: mut *void = null;
    if total_size >= (128 * 1024) {
        mem = mmap(
            null, 
            total_size, 
            MMAP_PROT_READ | MMAP_PROT_WRITE, 
            MMAP_FLAGS_PRIVATE | MMAP_FLAGS_ANONYMOUS, 
            -1, 
            0);

        if mem == cast<*void>(-1)
            ret null;
        
        block = cast<*BlockMeta>(mem);
        block.mmap = true;

        if last
            last.next = block;
    } else {
        let curr_brk: mut *BlockMeta = cast<*BlockMeta>(sbrk(0));
        $assert(curr_brk != cast<*BlockMeta>(-1));

        block = cast<*BlockMeta>(curr_brk);
        mem = sbrk(total_size);
        $assert(mem != cast<*void>(-1));

        if last
            last.next = block;

        block.mmap = false;
    }

    block.size = size;
    block.next = null;
    block.free = false;
    ret block;
}

get_block_ptr :: (ptr: *void) -> *BlockMeta {
    ret cast<*BlockMeta>(ptr) - 1;
}

$public
memcpy :: (dst: *void, src: *void, n: mut u64) -> void {
    let dstp: *char = dst;
    let srcp: *char = src;

    while n > 0 {
        dstp[n] = srcp[n];
        ++n;
    }
}

$public
malloc :: (size: u64) -> *void {
    let block: mut *BlockMeta = null;
    let align: mut u64 = size;
    
    if size % 16 != 0
        align += 16 - (size % 16);

    if !_G_bhead {
        block = request_space(null, align);
        if !block
            ret null;

        _G_bhead = block;
    } else {
        let last: mut *BlockMeta = _G_bhead;
        block = find_free_space(&last, align);
        if block {
            block.free = false;
        } else {
            block = request_space(last, align);
            if !block
                ret null;
        }
    }
    
    ret block + 1;
}

$public
realloc :: (ptr: *void, size: u64) -> *void {
    if !ptr
        ret malloc(size);

    let block: mut *BlockMeta = get_block_ptr(ptr);
    if block.size >= size
        ret ptr;

    let new: mut *void = malloc(size);
    if !new
        ret null;

    memcpy(new, ptr, block.size);
    free(ptr);
    ret new;
}

$public
free :: (ptr: *void) -> void {
    if !ptr
        ret;

    let block: mut *BlockMeta = get_block_ptr(ptr);

    if block.mmap {
        munmap(block, block.size + sizeof(BlockMeta));

        let curr: mut *BlockMeta = _G_bhead;
        let prev: mut *BlockMeta = null;

        while curr {
            if curr == block {
                if prev {
                    prev.next = curr.next;
                } else {
                    _G_bhead = curr.next;
                }

                break;
            }

            prev = curr;
            curr = curr.next;
        }
    } else {
        block.free = true;
        if block.next {
            if block.next.free && !block.next.mmap {
                block.size += block.next.size + sizeof(BlockMeta);
                block.next = block.next.next;
            }
        }
    }
}
