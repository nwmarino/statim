special_number :: mut s64 = 42;

main :: (argc: s64, argv: **char) -> s64 {
    test_iadd();
    test_fadd();
    test_isub();
    test_fsub();
    test_smul();
    test_umul();
    test_fmul();
    test_sdiv();
    test_udiv();
    test_fdiv();

    let p: *s64 = &special_number;
    *p = 11;

    ret special_number;
}

$public
test_iadd :: () -> void {
    let x: s64 = 4;
    $assert(7 == x + 3);
}

$public
test_fadd :: () -> void {
    let x: f64 = 0.14;
    $assert(3.14 == 3.0 + x);
}

$public
test_isub :: () -> void {
    let x: s64 = 7;
    $assert(11 == 18 - x);
}

$public
test_fsub :: () -> void {
    let x: f32 = 0.55;
    $assert(-1.5 == x - 2.05);
}

$public
test_smul :: () -> void {
    let x: s64 = 6;
    $assert(-30 == -5 * x);
}

$public
test_umul :: () -> void {
    let x: u64 = -3;
    $assert(15 == x * -5);
}

$public
test_fmul :: () -> void {
    let x: f32 = 1.5;
    $assert(cast<f32>(30) == cast<f32>(20) * 1.5);
}

$public
test_sdiv :: () -> void {
    let x: s64 = -4;
    $assert(-6 == 24 / x);
}

$public
test_udiv :: () -> void {
    let x: u64 = 16;
    $assert(8 == x / 2);
}

$public
test_fdiv :: () -> void {
    let x: f64 = 2.5;
    $assert(cast<f64>(20) == cast<f64>(50) / x);
}

iadd :: (x: s64, y: s64) -> s64 {
    ret x + y;
}

fadd :: (x: f64, y: f64) -> f64 {
    ret x + y;
}

isub :: (x: s32, y: s32) -> s32 {
    ret x - y;
}

fsub :: (x: f32, y: f32) -> f32 {
    ret x - y;
}

smul :: (x: s64, y: s64) -> s64 {
    ret x * y;
}

sdiv :: (x: s32, y: s32) -> s32 {
    ret x / y;
}

srem :: (x: s32, y: s32) -> s32 {
    ret x % y;
}

udiv :: (x: s64, y: s64) -> s64 {
    ret x / y;
}

umul :: (x: u32, y: u32) -> s32 {
    ret x * y;
}

urem :: (x: u64, y: u64) -> u64 {
    ret x % y;
}

fmul :: (x: f64, y: f64) -> f64 {
    ret x * y;
}

fdiv :: (x: f32, y: f32) -> f32 {
    ret x / y;
}

and :: (x: s8, y: s8) -> s8 {
    ret x & y;
}

or :: (x: s8, y: s8) -> s8 {
    ret x | y;
}

xor :: (x: s8, y: s8) -> s8 {
    ret x ^ y;
}

land :: (x: bool, y: bool) -> bool {
    ret x && y;
}

lor :: (x: bool, y: bool) -> bool {
    ret x || y;
}

shl :: (x: s64, y: s64) -> s64 {
    ret x << y;
}

shr :: (x: u64, y: s64) -> u64 {
    ret x >> y;
}

sar :: (x: s64, y: s64) -> s64 {
    ret x >> y;
}

sext32 :: (x: s16) -> s32 {
    ret x;
}

sext64 :: (x: s32) -> s64 {
    ret x;
}

zext32 :: (x: u16) -> u32 {
    ret x;
}

zext64 :: (x: u32) -> u64 {
    ret x;
}

itrunc :: (x: s64) -> s32 {
    ret x;
}

fext :: (x: f32) -> f64 {
    ret x;
}

ftrunc :: (x: f64) -> f32 {
    ret x;
}

address_of_deref :: (x: s64) -> s64 {
    let y: *s64 = &x;
    ret *y;
}

ptr_next :: (x: *s64) -> *s64 {
    ret x + 1;
}

ptr_next_arb :: (x: *s64, y: s64) -> *s64 {
    ret x + y;
}

if_6 :: (x: s64) -> s64 {
    if x == 6 {
        ret 0;
    } else {
        ret x;
    }
}

until_42 :: (x: s64) -> s64 {
    while x < 42 {
        x++;
    }

    while x > 42 {
        --x;
    }

    ret x;
}

memcpy :: (dst: *void, src: *void, n: mut u64) -> void {
    let dstp: *char = dst;
    let srcp: *char = src;
    let i: u64 = 0;

    while i < n {
        dstp[i] = srcp[i];
        ++i;
    }
}
